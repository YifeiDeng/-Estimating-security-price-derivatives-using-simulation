---
title: "Resimulation Method"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

*Reference Paper: Broadie, M. and Glasserman, P. (1996). Estimating security price derivatives using simulation, Management Science 42, 269â€“285.*

# 1. European Call Options on Dividend Paying Assets

## Resimulation Indirect Method (CRN) (w/o control variates)

>Table #1

The re-simulation estimator          Expression for
-----------------------------        ---------------------------------------
$Vega = \frac{dp}{d\sigma}$          $\frac{(P(\sigma_0+h) - P(\sigma_0))}{h}$
$Delta = \frac{dp}{dS_0}$            $\frac{(P(S_0+h) - P(S_0))}{h}$
$Gamma = \frac{d^2p}{dS_0^2}$        $\frac{(P(S_0-h) - 2P(S_0) + P(S_0+h))}{h^2}$
$Rho = \frac{dp}{dr}$                $\frac{(P(r_0+h) - P(r_0))}{h}$
$Theta = -\frac{dp}{dT}$             $-\frac{(P(T+h) - P(T))}{h}$

Where $P(\cdot)$ is the payoff of the European Call Options on dividend paying assets,
$$P = e^{-rT}\max(S_T-K,0)\text{, where } S_T \text{ is given by } S_T = S_0e^{(r-\delta-\frac{\sigma^2}{2})T-\sigma\sqrt{T}Z}\text{with Z a random standard normal distributed}$$

Thus, the simulation estimator for price of the European Call option with dividend paying assets is given by 
$$
\hat{C}_{re} = \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(S_{t_i}-K,0)
$$ 
where, $S_{t_i} = S_0e^{(r-\delta-\frac{\sigma^2}{2})T-\sigma\sqrt{T}\Phi^{-1}(U_i)}$ in this case, by inversion we are approximating standard normal Z by $\Phi^{-1}(U_i)$ with $U_i \sim i.i.d.Unifrom(0,1)$ random uniform over domain on (0,1).

And the re-simulation estimator for $Delta$ for example is
$$
\begin{align}
\hat{Delta}_{re} &= \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(\frac{P(\sigma_0+h) - P(\sigma_0)}{h}-K,0)\notag\\
& = \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(\frac{S_{t_i}(\sigma+h) - S_{t_i}(\sigma)}{h}-K,0)\notag
\end{align}
$$
depending on parameter of interest from **Table #1**. In this case, common random numbers are used i.e. the random number are generated by the same stream of random nmuber for i = 1,...,n instead of independent random stream of numbers.

**Define function for estimating European Call options derivatives using re-simulation method under BS model**

variables                      output 
--------------------           -----------------------------------
n: # of simulations            hat_re: the estimated derivatives of an European call option using re-simulation
S0: the spot price             hat_std_err: the standard error for estimating the derivatives of an European call option using re-simulation
r: the rate of return          call: the estimated European call option price using re-simulations
sigma: volatility              call_std_err: the standard error for estimating the price of an European call option using re-simulation
T: maturity date
K: strike price
delta: dividend
h: time step for FD
input: 'delta', 'vega',etc...

```{r}
resimulation <- function(n, S0, r, sigma, T, K, delta, h, input)
{
  # create payoff
  C = matrix(0,n,1)
  
  # create perturb payoff
  C_h = matrix(0,n,1)
  
  # create length n random normal vector before simulations
  zi = qnorm(runif(n,0,1))
  
  # create derivatives to store the estimated Greeks at each simulation
  derivatives = matrix(0,n,1)
  
  # create matrices for storing the stock at each simulation
  stock = matrix(0,n,1)
  stock_h = matrix(0,n,1)
  
  if(input == 'delta')
  {
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      stock_h[i] = (S0 + h) * exp((r - delta - sigma^2/2)*T 
                                    + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    # determine the estimator for delta of a plain call option
    hat = sum(derivatives)/n
    call = sum(C)/n # estimated call option price
    
    # determine the standard error of the estimator
    hat_std_err = sqrt(var(derivatives)/n)
    call_std_err = sqrt(var(C)/n) # estimated std err for call option price
    
    # return the desire output
    return(c(hat, hat_std_err,call,call_std_err))
    
  }else if (input == 'vega'){ 
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp((r - delta - (sigma + h)^2/2)*T 
                                  + (sigma+h) * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for vega for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
  # determine the estimator for vega of a plain call option
  hat = sum(derivatives)/n
  call = sum(C)/n # estimated call option price
  
  # determine the standard error of the estimator
  hat_std_err = sqrt(var(derivatives)/n)
  call_std_err = sqrt(var(C)/n) # estimated std err for call option price
  
  # return the desire output
  return(c(hat, hat_std_err, call, call_std_err))
  
  }else if (input == 'gamma'){
    # create additional payoff & price by perturb price
    # for second order derivatives
    stock_h_1 = matrix(0,n,1)
    C_h_1 = matrix(0,n,1)
    
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = (S0 + h) * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      stock_h_1[i] = (S0 - h) * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      C_h_1[i] = exp(-r*T) * max(stock_h_1[i] - K, 0)
      
      # gives estimate for gamma for each simulation
      # central finite difference
      derivatives[i] = (C_h_1[i] - 2*C[i] + C_h[i]) / h^2
    }
    # determine the estimator for gamma of a plain call option
    hat = sum(derivatives)/n
    call = sum(C)/n # estimated call option price
    
    # determine the standard error of the estimator
    hat_std_err = sqrt(var(derivatives)/n)
    call_std_err = sqrt(var(C)/n) # estimated std err for call option price
    
    # return the desire output
    return(c(hat, hat_std_err, call, call_std_err))
    
  }else if (input == 'rho'){
    
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp(((r + h) - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-(r+h)*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for rho for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    # determine the estimator for rho of a plain call option
    hat = sum(derivatives)/n
    call = sum(C)/n # estimated call option price
    
    # determine the standard error of the estimator
    hat_std_err = sqrt(var(derivatives)/n)
    call_std_err = sqrt(var(C)/n) # estimated std err for call option price
    
    # return the desire output
    return(c(hat, hat_std_err,call,call_std_err))
    
  }else if (input == 'theta'){
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp((r - delta - sigma^2/2)*(T + h) 
                            + sigma * sqrt(T + h) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*(T + h)) * max(stock_h[i] - K, 0)
      
      # gives estimate for theta for each simulation
      derivatives[i] = -(C_h[i] - C[i]) / h
    }
    # determine the estimator for theta of a plain call option
    hat = sum(derivatives)/n
    call = sum(C)/n # estimated call option price
    
    # determine the standard error of the estimator
    hat_std_err = sqrt(var(derivatives)/n)
    call_std_err = sqrt(var(C)/n) # estimated std err for call option price
    
    # return the desire output
    return(c(hat, hat_std_err,call,call_std_err))
    
  }else if (input == 'call_control_variate'){
    # define E[S_T]
    S_T_i = exp((r-delta)*T) * S0
    
    # generate stock price for each simulation
    stock = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi)
    
    # define call using simulation
    C = exp(-r*T) * pmax(stock - K, 0)
    
    # estimate beta
    beta = c(cov(C, stock)/ var(stock))
    
    # calculate the payoff C and C_h accordingly
    C_cv = C + beta * (S_T_i - stock)
    
    # estimated call option price
    call_cv = sum(C_cv)/n 
    
    # estimated std err for call option price
    call_cv_std_err = sqrt(var(C_cv)/n)
    
    return(c(call_cv, call_cv_std_err))
    
  }else{
    cat('Please type in the proper name of the derivative! e.g. delta, gamma etc.')
  }
}
```

**initialized variables as the article suggested**
```{r}
# set variables
n = 10000 # simulation tuns
# S0 = 110
# S0 = 110
S0 = 110
r = 0.1
K = 100 
delta = 0.03
sigma = 0.25
T = 0.2
# choose h = 0.05 for gamma
h = 0.0001
```

**The simulated call option price**
```{r}
result = resimulation(n, S0, r, sigma, T, K, delta, h, 'delta')
call = result[3]
call_std_err = result[4]
call_t = cbind(call, call_std_err)
colnames(call_t) = c('Simlulated Call Price', 'Std Error for Simulation Estimates')
kable(call_t)
```

**The simulated call option price with control variate**
```{r}
result_cv = resimulation(n, S0, r, sigma, T, K, delta, h, 'call_control_variate')
call_cv = result_cv[1]
call_cv_std_err = result_cv[2]
call_cv_t = cbind(call_cv, call_cv_std_err)
colnames(call_cv_t) = c('Simlulated Call Price with CV', 'Std Error for Simulation Estimates')
kable(call_cv_t)
```

**$Delta$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation(n, S0, r, sigma, T, K, delta, h, 'delta')
proc.time() - ptm
Delta_re = result[1]
Delta_re_Std_err = result[2]

result = cbind(mean(Delta_re), mean(Delta_re_Std_err))
colnames(result) = c('Delta uisng resimulation', 'Std Err')
kable(result)
```


**$Vega$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation(n, S0, r, sigma, T, K, delta, h, 'vega')
proc.time() - ptm
Vega_re = result[1]
Vega_re_Std_err = result[2]

result = cbind(mean(Vega_re), mean(Vega_re_Std_err))
colnames(result) = c('Vega uisng resimulation', 'Std Err')
kable(result)
```

**$Gamma$**

```{r}
set.seed(123)
# choose h = 0.05 for gamma
h = 0.05
ptm <- proc.time()

result =  resimulation(n, S0, r, sigma, T, K, delta, h, 'gamma')
proc.time() - ptm
Gamma_re = result[1]
Gamma_re_Std_err = result[2]

result = cbind(mean(Gamma_re), mean(Gamma_re_Std_err))
colnames(result) = c('Gamma uisng resimulation', 'Std Err')
kable(result)
```

**$Rho$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation(n, S0, r, sigma, T, K, delta, h, 'rho')
proc.time() - ptm
Rho_re = result[1]
Rho_re_Std_err = result[2]

result = cbind(mean(Rho_re), mean(Rho_re_Std_err))
colnames(result) = c('Gamma uisng resimulation', 'Std Err')
kable(result)
```

**$Theta$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation(n, S0, r, sigma, T, K, delta, h, 'theta')
proc.time() - ptm
Theta_re = result[1]
Theta_re_Std_err = result[2]

result = cbind(mean(Theta_re), mean(Theta_re_Std_err))
colnames(result) = c('Gamma uisng resimulation', 'Std Err')
kable(result)
```

## Resimulation Indirect Method (CRN) (w control variates)

**Define function for estimating European Call options derivatives using re-simulation method under BS model (with control variate)**

variables                      output 
--------------------           -----------------------------------
n: # of simulations            hat_re_cv: the estimated derivatives of an European call option using re-simulation with control variate
S0: the spot price             hat_re_std_err_cv: the standard error for estimating the derivatives of an European call option using re-simulation with control variate
r: the rate of return          
sigma: volatility             
T: maturity date
K: strike price
delta: dividend
h: time step for FD
input: 'delta', 'vega',etc...

```{r}
resimulation_cv <- function(n, S0, r, sigma, T, K, delta, h, input)
{
  # create payoff
  C = matrix(0,n,1)
  
  # create perturb payoff
  C_h = matrix(0,n,1)
  
  # define E[S_T] as S_T_i
  S_T_i = S0 * exp((r - delta)*T)
  
  # create length n random normal vector before simulations
  zi = qnorm(runif(n,0,1))
  
  # create derivatives to store the estimated Greeks at each simulation
  derivatives = matrix(0,n,1)
  
  # create matrices for storing the stock at each simulation
  stock = matrix(0,n,1)
  stock_h = matrix(0,n,1)
  
  if(input == 'delta')
  {
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      stock_h[i] = (S0 + h) * exp((r - delta - sigma^2/2)*T 
                                    + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    # estimate beta
    beta = c(cov(derivatives, stock)/ var(stock))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - stock)
    
    # determine the estimator for delta of a plain call option
    hat_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_re_cv, hat_re_cv_std_err))
    
  }else if (input == 'vega'){ 
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp((r - delta - (sigma + h)^2/2)*T 
                                  + (sigma+h) * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for vega for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    # estimate beta
    beta = c(cov(derivatives, stock)/ var(stock))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - stock)
    
    # determine the estimator for delta of a plain call option
    hat_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_re_cv, hat_re_cv_std_err))
  
  }else if (input == 'gamma'){
    # create additional payoff & price by perturb price
    # for second order derivatives
    stock_h_1 = matrix(0,n,1)
    C_h_1 = matrix(0,n,1)
    
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = (S0 + h) * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      stock_h_1[i] = (S0 - h) * exp((r - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*T) * max(stock_h[i] - K, 0)
      C_h_1[i] = exp(-r*T) * max(stock_h_1[i] - K, 0)
      
      # gives estimate for gamma for each simulation
      # central finite difference
      derivatives[i] = (C_h_1[i] - 2*C[i] + C_h[i]) / h^2
    }
    # estimate beta
    beta = c(cov(derivatives, stock)/ var(stock))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - stock)
    
    # determine the estimator for delta of a plain call option
    hat_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_re_cv, hat_re_cv_std_err))
    
  }else if (input == 'rho'){
    
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp(((r + h) - delta - sigma^2/2)*T 
                            + sigma * sqrt(T) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-(r+h)*T) * max(stock_h[i] - K, 0)
      
      # gives estimate for rho for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    # estimate beta
    beta = c(cov(derivatives, stock)/ var(stock))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - stock)
    
    # determine the estimator for delta of a plain call option
    hat_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_re_cv, hat_re_cv_std_err))
    
  }else if (input == 'theta'){
    for(i in 1:n)
    {
      # generate stock price for each simulation
      stock[i] = S0 * exp((r - delta - sigma^2/2)*T 
                          + sigma * sqrt(T) * zi[i])
      stock_h[i] = S0 * exp((r - delta - sigma^2/2)*(T + h) 
                            + sigma * sqrt(T + h) * zi[i])
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r*T) * max(stock[i] - K, 0)
      C_h[i] = exp(-r*(T + h)) * max(stock_h[i] - K, 0)
      
      # gives estimate for theta for each simulation
      derivatives[i] = -(C_h[i] - C[i]) / h
    }
    # estimate beta
    beta = c(cov(derivatives, stock)/ var(stock))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - stock)
    
    # determine the estimator for delta of a plain call option
    hat_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_re_cv, hat_re_cv_std_err))
    
  }else{
    cat('Please type in the proper name of the derivative! e.g. delta, gamma etc.')
  }
}
```

**$Delta$**

```{r}
set.seed(123)
ptm <- proc.time()
result =  resimulation_cv(n, S0, r, sigma, T, K, delta, h, 'delta')
proc.time() - ptm
Delta_re = result[1]
Delta_re_Std_err = result[2]

result = cbind(mean(Delta_re), mean(Delta_re_Std_err))
colnames(result) = c('Delta uisng resimulation with CV', 'Std Err')
kable(result)
```


**$Vega$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation_cv(n, S0, r, sigma, T, K, delta, h, 'vega')
proc.time() - ptm
Vega_re = result[1]
Vega_re_Std_err = result[2]

result = cbind(mean(Vega_re), mean(Vega_re_Std_err))
colnames(result) = c('Vega uisng resimulation with CV', 'Std Err')
kable(result)
```

**$Gamma$**

```{r}
set.seed(123)
# choose h = 0.05 for gamma
h = 0.05
ptm <- proc.time()

result =  resimulation_cv(n, S0, r, sigma, T, K, delta, h, 'gamma')
proc.time() - ptm
Gamma_re = result[1]
Gamma_re_Std_err = result[2]

result = cbind(mean(Gamma_re), mean(Gamma_re_Std_err))
colnames(result) = c('Gamma uisng resimulation with CV', 'Std Err')
kable(result)
```

**$Rho$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_cv(n, S0, r, sigma, T, K, delta, h, 'rho')
proc.time() - ptm
Rho_re = result[1]
Rho_re_Std_err = result[2]

result = cbind(mean(Rho_re), mean(Rho_re_Std_err))
colnames(result) = c('Gamma uisng resimulation with CV', 'Std Err')
kable(result)
```

**$Theta$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_cv(n, S0, r, sigma, T, K, delta, h, 'theta')
proc.time() - ptm
Theta_re = result[1]
Theta_re_Std_err = result[2]

result = cbind(mean(Theta_re), mean(Theta_re_Std_err))
colnames(result) = c('Gamma uisng resimulation with CV', 'Std Err')
kable(result)
```


## Exact Value of Greeks

$$
\begin{align}
Delta(\frac{dp}{dS_0}) &= e^{-\delta T}N(d_1(K))\notag\\
Vega(\frac{dp}{d\sigma}) &= \sqrt{T}e^{-\delta T}S_0n(d_1(K))\notag\\
Gamma(\frac{d^2p}{dS_0^2}) &= e^{-\delta T}\frac{n(d_1(K))}{S_0\sigma\sqrt{T}}\notag\\
Rho(\frac{dp}{dr}) &= KTe^{-rT}N(d_2(K))\notag\\
Theta(-\frac{dp}{dT}) &= -\frac{\sigma e^{-\delta T}S_0n(d_1(K))}{2\sqrt{T}}+\delta e^{-\delta T}S_0N(d_1(K)) - rKe^{-rT}N(d_2(K))\notag
\end{align}
$$
Where, 
$$
d_1(x) = \frac{[ln(\frac{S_0}{x}) + (r-\delta+\frac{1}{2}\sigma^2)T]}{\sigma\sqrt{T}} = -d(x) + \sigma\sqrt{T},
$$
and $d_2 = -d(x)$, $N(\cdot)$ is the culmulative distribution function of a standard normal random variables
**initialized some common used variables**
```{r}
d1 = (log(S0/K) + (r - delta + 1/2*sigma^2)*T)/(sigma*sqrt(T))
d = sigma*sqrt(T) - d1
d2 = -d
```


```{r, warning = FALSE}
delta_exact = exp(-delta*T)*pnorm(d1)
vega_exact = sqrt(T)*exp(-delta*T)*S0*dnorm(d1)
gamma_exact = exp(-delta*T)*dnorm(d1)/(S0*sigma*sqrt(T))
rho_exact = K*T*exp(-r*T)*pnorm(d2)
theta_exact = (-sigma*exp(-delta*T)*S0*dnorm(d1))/(2*sqrt(T)) +
              delta*exp(-delta*T)*S0*pnorm(d1) - r*K*exp(-r*T)*pnorm(d2)

result = rbind(delta_exact, vega_exact, gamma_exact, rho_exact, theta_exact)
rownames(result) = c('Exact delta', 'Exact vega', 'Exact gamma', 'Exact rho', 'Exact theta')
kable(result)
```

# 2. Asian Call Option (option wiht arithmetic average price)

## Resimulation Indirect Method (CRN) (w\o control varites)

We are using the same re-simulaiton estimators from **Table #1**

The re-simulation estimator          Expression for
-----------------------------        ---------------------------------------
$Vega = \frac{dp}{d\sigma}$          $\frac{(P(\sigma_0+h) - P(\sigma_0))}{h}$
$Delta = \frac{dp}{dS_0}$            $\frac{(P(S_0+h) - P(S_0))}{h}$
$Gamma = \frac{d^2p}{dS_0^2}$        $\frac{(P(S_0-h) - 2P(S_0) + P(S_0+h))}{h^2}$
$Rho = \frac{dp}{dr}$                $\frac{(P(r_0+h) - P(r_0))}{h}$
$Theta = -\frac{dp}{dT}$             $-\frac{(P(T+h) - P(T))}{h}$

Where $P(\cdot)$ is the payoff of the Asian Call Options with arithmetic average price,
$$
\begin{align}
P = e^{-rT}\max(\frac{1}{s}\sum^{s}_{j=1}S^i_{t_j}-K,0)\text{, where } S^i_{t_j} \text{ is given by } S^i_{t_j} = S^i_{t_{j-1}}e^{(r-\delta-\frac{\sigma^2}{2})\Delta+\sigma\sqrt{\Delta}Z}\text{with Z a random standard normal distributed and }\notag\\
\text{starting with }t_1 = T-\frac{(s-1)}{365.25},\text{and then recursively for } t_j=T-\frac{(s-j)}{365.25},j=2,...,s,\Delta = \frac{1}{365.25}
\end{align}
$$

Thus, the simulation estimator for price of the Asian Call option with arithmetic average price is given by 
$$
\hat{C}_{re} = \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(\frac{1}{s}\sum^{s}_{j=1}S^i_{t_j}-K,0)
$$ 
where $S^i_{t_j}$ is given as this recursive form: $S^i_{t_j} = S^i_0e^{(r-\delta-\frac{\sigma^2}{2})t_j+\sigma\sqrt{t_j}\Phi^{-1}(U_{ij})}$ with $t_j=T-\frac{(s-j)}{365.25}$, i = 1,...,n, j = 1,...s. In this case, by inversion we are approximating standard normal Z by $\Phi^{-1}(U_{ij})$ with $U_i \sim i.i.d.Unifrom(0,1)$ random uniform over domain on (0,1). However, for estimating $Theta$, $t_j$ is defined as a fixed increment where $t_j = \Delta j$ with $\Delta = \frac{T}{s}$.

And the re-simulation estimator for $Vega$ for example is
$$
\begin{align}
\hat{Vega}_{re} &= \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(\frac{P(\sigma_0+h) - P(\sigma_0)}{h}-K,0)\notag\\
& = \frac{1}{n}\sum_{i=1}^ne^{-rT}\max(\frac{S^i_{t_j}(\sigma+h) - S^i_{t_j}(\sigma)}{h}-K,0)\notag
\end{align}
$$
depending on parameter of interest from **Table #1**. In this case, common random numbers are used i.e. the random number are generated by the same stream of random nmuber for i = 1,...,n instead of independent random stream of numbers.

**Define function for estimating Asian Call options derivatives using re-simulation method under BS model w\o control variates**

variables                      output 
--------------------           -----------------------------------
n: # of simulations            hat_A_re: the estimated derivatives of an Asian call option using re-simulation
S0: the spot price             hat_A_re_std_err: the standard error for estimating the derivatives of an Asian call option using re-simulation
r: the rate of return          call_A: estimated price of the Asian call option by simulations
sigma: volatility              call_A_std_err: the standard error for estimating the Asian call option by simulations
T: maturity date               hat_C_A_cv: estimated price of the Asian call option by simulations using CV method
K: strike price                hat_C_A_cv_std_err: the standard error for estimating the Asian call option by simulations using CV method
delta: dividend
h: time step for FD
input: 'delta', 'vega',etc...
s: the last s days 

```{r}
resimulation_A <- function(n, S0, r, sigma, T, K, delta, h, input,s)
{
  # create payoff
  C = matrix(0,n,1)
  
  # create perturb payoffs
  C_h = matrix(0,n,1)
  
  # create length n random normal vector before simulations
  zi = matrix(qnorm(runif(n*s,0,1)),ncol=s,nrow=n)
  
  # create derivatives to store the estimated Greeks at each simulation
  derivatives = matrix(0,n,1)
  
  # create tj for each increment of last few days
  if(input == 'theta')
  {
    t_j = c(T - (s-1)/365.25, rep(1/365.25, s-1))
    t_h_j = c(T - (s-1)/365.25+h, rep(1/365.25, s-1))
  }else{
    t_j = c(T - (s-1)/365.25, rep(1/365.25, s-1))
  }
  
  if(input == 'delta')
  {
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0 - h
      stock_h[1] = S0 + h
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-(S0 + h))/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / (2*h)
    }
    hat_A_re = sum(derivatives)/n
    
    # determine the standard error of the estimator
    hat_A_re_std_err = sqrt(var(derivatives)/n)
    
    # return the desire output
    return(c(hat_A_re, hat_A_re_std_err))
    
  }else if (input == 'vega'){ 
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - (sigma+h)^2/2) * t_j[j-1] + (sigma+h) * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    hat_A_re = sum(derivatives)/n
    
    # determine the standard error of the estimator
    hat_A_re_std_err = sqrt(var(derivatives)/n)
    
    # return the desire output
    return(c(hat_A_re, hat_A_re_std_err))
  
  }else if (input == 'gamma'){
    # create perturb price
    C_h_1 = matrix(0,n,1)
    
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      stock_h_1 = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0 + h
      stock_h_1[1] = S0 - h
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h_1[j] = stock_h_1[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-(S0 + h))/s - K)
      C_h_1[i] = exp(-r * T) * max(0, (sum(stock_h_1)-(S0 - h))/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h_1[i] - 2*C[i] + C_h[i]) / h^2
    }
    hat_A_re = sum(derivatives)/n
    
    # determine the standard error of the estimator
    hat_A_re_std_err = sqrt(var(derivatives)/n)
    
    # return the desire output
    return(c(hat_A_re, hat_A_re_std_err))
    
  }else if (input == 'rho'){
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp(((r+h) - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(- (r+h) * T) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
    }
    hat_A_re = sum(derivatives)/n
    
    # determine the standard error of the estimator
    hat_A_re_std_err = sqrt(var(derivatives)/n)
    
    # return the desire output
    return(c(hat_A_re, hat_A_re_std_err))
    
  }else if (input == 'theta'){
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * (t_h_j[j-1]) + sigma * sqrt(t_h_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(- r * (T+h)) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = -(C_h[i] - C[i]) / h
    }
    hat_A_re = sum(derivatives)/n
    
    # determine the standard error of the estimator
    hat_A_re_std_err = sqrt(var(derivatives)/n)
    
    # return the desire output
    return(c(hat_A_re, hat_A_re_std_err))
    
  }else if (input == 'call_price'){
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
    }
    call_A = sum(C)/n
    
    # determine the standard error of the estimator
    call_A_std_err = sqrt(var(C)/n)
    
    # return the desire output
    return(c(call_A, call_A_std_err))
  }else if (input == 'call_control_variate'){
    # define matrix for stock price
    stock_price = matrix(0,n,1)
    
    # define E[S_T] as S_T_i
    S_T_i = S0 * exp((r - delta)*T)
    
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # store the stock price at each n simulation
      stock_price[i] = stock[s+1]
      
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
    }
    # estimate beta
    beta = c(cov(C, stock_price)/ var(stock_price))
    
    # apply control variates to the method
    C_A_cv = C + beta*(S_T_i - stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_C_A_cv = sum(C_A_cv)/n
    
    # determine the standard error of the estimator
    hat_C_A_cv_std_err = sqrt(var(C_A_cv)/n)
    
    # return the desire output
    return(c(hat_C_A_cv, hat_C_A_cv_std_err))
  }else{
    cat('Please type in the proper name of the derivative! e.g. delta, gamma etc.')
  }
}
```

**initialized variables as the article suggested**
```{r}
# set variables
n = 10000 # simulation tuns
s = 30 # stock price steps
# S0 = 110
# S0 = 110
S0 = 110
r = 0.1
K = 100 
delta = 0.03
sigma = 0.25
T = 0.2
# choose h = 0.05 for gamma
h = 0.0001
```

**The simulated call option price**
```{r}
result = resimulation_A(n, S0, r, sigma, T, K, delta, h, 'call_price',s)
call = result[1]
call_std_err = result[2]
call_t = cbind(call, call_std_err)
colnames(call_t) = c('Simlulated Asian Call Price', 'Std Error for Simulation Estimates')
kable(call_t)
```

**The simulated call option price with control variate**
```{r}
result_cv = resimulation_A(n, S0, r, sigma, T, K, delta, h, 'call_control_variate',s)
call_cv = result_cv[1]
call_cv_std_err = result_cv[2]
call_cv_t = cbind(call_cv, call_cv_std_err)
colnames(call_cv_t) = c('Simlulated Asian Call Price with CV', 'Std Error for Simulation Estimates')
kable(call_cv_t)
```

**$Delta$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation_A(n, S0, r, sigma, T, K, delta, h, 'delta',s)
proc.time() - ptm
Delta_re = result[1]
Delta_re_Std_err = result[2]

result = cbind(mean(Delta_re), mean(Delta_re_Std_err))
colnames(result) = c('Delta of Asian Call using resimulation', 'Std Err')
kable(result)
```


**$Vega$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation_A(n, S0, r, sigma, T, K, delta, h, 'vega',s)
proc.time() - ptm
Vega_re = result[1]
Vega_re_Std_err = result[2]

result = cbind(mean(Vega_re), mean(Vega_re_Std_err))
colnames(result) = c('Vega of Asian Call using resimulation', 'Std Err')
kable(result)
```

**$Gamma$**

```{r}
set.seed(123)
# choose h = 0.05 for gamma
h = 0.05
ptm <- proc.time()

result =  resimulation_A(n, S0, r, sigma, T, K, delta, h, 'gamma',s)
proc.time() - ptm
Gamma_re = result[1]
Gamma_re_Std_err = result[2]

result = cbind(mean(Gamma_re), mean(Gamma_re_Std_err))
colnames(result) = c('Gamma of Asian Call using resimulation', 'Std Err')
kable(result)
```

**$Rho$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_A(n, S0, r, sigma, T, K, delta, h, 'rho',s)
proc.time() - ptm
Rho_re = result[1]
Rho_re_Std_err = result[2]

result = cbind(mean(Rho_re), mean(Rho_re_Std_err))
colnames(result) = c('Rho of Asian Call using resimulation', 'Std Err')
kable(result)
```

**$Theta$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_A(n, S0, r, sigma, T, K, delta, h, 'theta',s)
proc.time() - ptm
Theta_re = result[1]
Theta_re_Std_err = result[2]

result = cbind(mean(Theta_re), mean(Theta_re_Std_err))
colnames(result) = c('Theta of Asian Call using resimulation', 'Std Err')
kable(result)
```

## Resimulation Indirect Method (CRN) (w control varites)

**Define function for estimating Asian Call options derivatives using re-simulation method under BS model w\o control variates**

variables                      output 
--------------------           -----------------------------------
n: # of simulations            hat_A_re_cv: the estimated derivatives of an Asian call option using re-simulation with CV method
S0: the spot price             hat_A_re_cv_std_err: the standard error for estimating the derivatives of an Asian call option using re-simulation with CV method
r: the rate of return          
sigma: volatility              
T: maturity date               
K: strike price                
delta: dividend
h: time step for FD
input: 'delta', 'vega',etc...
s: the last s days 

```{r}
resimulation_A_cv <- function(n, S0, r, sigma, T, K, delta, h, input,s)
{
  # create payoff
  C = matrix(0,n,1)
  
  # create perturb payoffs
  C_h = matrix(0,n,1)
  
  # create length n random normal vector before simulations
  zi = matrix(qnorm(runif(n*s,0,1)),ncol=s,nrow=n)
  
  # define E[S_T] as S_T_i
  S_T_i = S0 * exp((r - delta)*T)
  
  # define matrix for store stock at each n simulation
  Stock_price = matrix(0,n,1)
  
  # create derivatives to store the estimated Greeks at each simulation
  derivatives = matrix(0,n,1)
  
  # create tj for each increment of last few days
  if(input == 'theta')
  {
    t_j = c(T - (s-1)/365.25, rep(1/365.25, s-1))
    t_h_j =c(T - (s-1)/365.25 + h, rep(1/365.25, s-1))
  }else{
    t_j = c(T - (s-1)/365.25, rep(1/365.25, s-1))
  }
  
  if(input == 'delta')
  {
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0 + h
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-(S0 + h))/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
      
      # store the terminal price of the underlying at each n
      Stock_price[i] = stock[s+1]
    }
    # estimate beta
    beta = c(cov(derivatives, Stock_price)/ var(Stock_price))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - Stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_A_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_A_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_A_re_cv, hat_A_re_cv_std_err))
    
  }else if (input == 'vega'){ 
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - (sigma+h)^2/2) * t_j[j-1] + (sigma+h) * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
      
      # store the terminal price of the underlying at each n
      Stock_price[i] = stock[s+1]
    }
    # estimate beta
    beta = c(cov(derivatives, Stock_price)/ var(Stock_price))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - Stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_A_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_A_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_A_re_cv, hat_A_re_cv_std_err))
  
  }else if (input == 'gamma'){
    # create perturb price
    C_h_1 = matrix(0,n,1)
    
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      stock_h_1 = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0 + h
      stock_h_1[1] = S0 - h
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h_1[j] = stock_h_1[j-1]*
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(-r * T) * max(0, (sum(stock_h)-(S0 + h))/s - K)
      C_h_1[i] = exp(-r * T) * max(0, (sum(stock_h_1)-(S0 - h))/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h_1[i] - 2*C[i] + C_h[i]) / h^2
      
      # store the terminal price of the underlying at each n
      Stock_price[i] = stock[s+1]
    }
    # estimate beta
    beta = c(cov(derivatives, Stock_price)/ var(Stock_price))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - Stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_A_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_A_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_A_re_cv, hat_A_re_cv_std_err))
    
  }else if (input == 'rho'){
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp(((r+h) - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(- (r+h) * T) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = (C_h[i] - C[i]) / h
      
      # store the terminal price of the underlying at each n
      Stock_price[i] = stock[s+1]
    }
    # estimate beta
    beta = c(cov(derivatives, Stock_price)/ var(Stock_price))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - Stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_A_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_A_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_A_re_cv, hat_A_re_cv_std_err))
    
  }else if (input == 'theta'){
    # start the simulation
    for(i in 1:n)
    {
      # define matrix that store the stock price along the path
      stock = matrix(0,s+1,1)
      stock_h = matrix(0,s+1,1)
      
      # initialized with spot price
      stock[1] = S0
      stock_h[1] = S0
      
      # calculate the stock price in each path
      for(j in 2:(s+1))
      {
        # generate stock price for each simulation
        stock[j] = stock[j-1]* 
          exp((r - delta - sigma^2/2) * t_j[j-1] + sigma * sqrt(t_j[j-1]) * zi[i,j-1])
        
        stock_h[j] = stock_h[j-1]*
          exp((r - delta - sigma^2/2) * (t_h_j[j-1]) + sigma * sqrt(t_h_j[j-1]) * zi[i,j-1])
      }
      # calculate the payoff C and C_h accordingly
      C[i] = exp(-r * T) * max(0, (sum(stock)-S0)/s - K)
      C_h[i] = exp(- r * (T+h)) * max(0, (sum(stock_h)-S0)/s - K)
      
      # gives estimate for delta for each simulation
      derivatives[i] = -(C_h[i] - C[i]) / h
      
      # store the terminal price of the underlying at each n
      Stock_price[i] = stock[s+1]
    }
    # estimate beta
    beta = c(cov(derivatives, Stock_price)/ var(Stock_price))
    
    # apply control variates to the method
    derivatives_cv = derivatives + beta*(S_T_i - Stock_price)
    
    # determine the estimator for delta of a plain call option
    hat_A_re_cv = sum(derivatives_cv)/n
    
    # determine the standard error of the estimator
    hat_A_re_cv_std_err = sqrt(var(derivatives_cv)/n)
    
    # return the desire output
    return(c(hat_A_re_cv, hat_A_re_cv_std_err))
  }else{
    cat('Please type in the proper name of the derivative! e.g. delta, gamma etc.')
  }
}
```

**$Delta$**

```{r}
set.seed(123)
ptm <- proc.time()
result =  resimulation_A_cv(n, S0, r, sigma, T, K, delta, h, 'delta',s)
proc.time() - ptm
Delta_re = result[1]
Delta_re_Std_err = result[2]

result = cbind(mean(Delta_re), mean(Delta_re_Std_err))
colnames(result) = c('Delta of Asian Call using resimulation with CV', 'Std Err')
kable(result)
```


**$Vega$**

```{r}
set.seed(123)
ptm <- proc.time()

result =  resimulation_A_cv(n, S0, r, sigma, T, K, delta, h, 'vega',s)
proc.time() - ptm
Vega_re = result[1]
Vega_re_Std_err = result[2]

result = cbind(mean(Vega_re), mean(Vega_re_Std_err))
colnames(result) = c('Vega of Asian Call using resimulation with CV', 'Std Err')
kable(result)
```

**$Gamma$**

```{r}
set.seed(123)
# choose h = 0.05 for gamma
h = 0.05
ptm <- proc.time()

result =  resimulation_A_cv(n, S0, r, sigma, T, K, delta, h, 'gamma',s)
proc.time() - ptm
Gamma_re = result[1]
Gamma_re_Std_err = result[2]

result = cbind(mean(Gamma_re), mean(Gamma_re_Std_err))
colnames(result) = c('Gamma of Asian Call using resimulation with CV', 'Std Err')
kable(result)
```

**$Rho$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_A_cv(n, S0, r, sigma, T, K, delta, h, 'rho',s)
proc.time() - ptm
Rho_re = result[1]
Rho_re_Std_err = result[2]

result = cbind(mean(Rho_re), mean(Rho_re_Std_err))
colnames(result) = c('Rho of Asian Call using resimulation with CV', 'Std Err')
kable(result)
```

**$Theta$**

```{r}
set.seed(123)
h = 0.0001
ptm <- proc.time()

result =  resimulation_A_cv(n, S0, r, sigma, T, K, delta, h, 'theta',s)
proc.time() - ptm
Theta_re = result[1]
Theta_re_Std_err = result[2]

result = cbind(mean(Theta_re), mean(Theta_re_Std_err))
colnames(result) = c('Theta of Asian Call using resimulation with CV', 'Std Err')
kable(result)
```
